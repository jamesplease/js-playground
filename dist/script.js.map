{"version":3,"sources":["script.js"],"names":[],"mappings":";;;;;;;;AAAA,AAAC,CAAA,UAAU,MAAM,EAAE,OAAO,EAAE;AAC1B,SAAO,OAAO,KAAK,QAAQ,IAAI,OAAO,MAAM,KAAK,WAAW,GAAG,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE,OAAO,CAAC,YAAY,CAAC,EAAE,OAAO,CAAC,qBAAqB,CAAC,CAAC,GAChJ,OAAO,MAAM,KAAK,UAAU,IAAI,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC,CAAC,QAAQ,EAAE,YAAY,EAAE,qBAAqB,CAAC,EAAE,OAAO,CAAC,GAC7G,OAAO,CAAC,MAAM,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,EAAE,MAAM,CAAC,EAAE,CAAC,CAAA;CACvC,CAAA,CAAC,IAAI,EAAE,UAAU,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE;AAAE,cAAY,CAAC;;MAEnC,UAAU;;;;;;AAKH,aALP,UAAU,GAKA;4BALV,UAAU;;;;AASZ,iCATE,UAAU,6CASJ;KACT;;cAVG,UAAU;;iBAAV,UAAU;;;;aAaD,yBAAG;AACd,YAAI,YAAY,8BAdd,UAAU,8CAc4B,CAAC;AACzC,oBAAY,CAAC,IAAI,GAAG,aAAa,CAAC;AAClC,eAAO,YAAY,CAAC;OACrB;;;;;;;;;;;WASW,YAAG;AACb,eAAO,CAAC,CAAC,QAAQ,CAAC,uCAAuC,CAAC,CAAC;OAC5D;;;;;;aAIc,oBAAG;AAChB,eAAO,cAAc,CAAC;OACvB;;;WAlCG,UAAU;KAAS,EAAE,CAAC,QAAQ;;AAqCpC,MAAI,UAAU,GAAG,IAAI,UAAU,EAAE,CAAC;;;AAGlC,YAAU,CAAC,MAAM,EAAE,CAAC;AACpB,GAAC,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;;;;CAuBjC,CAAC,CAAE","file":"script.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('jquery'), require('underscore'), require('backbone.marionette')) :\n  typeof define === 'function' && define.amd ? define(['jquery', 'underscore', 'backbone.marionette'], factory) :\n  factory(global.$, global._, global.Mn)\n}(this, function ($, _, Mn) { 'use strict';\n\n  class CustomView extends Mn.ItemView {\n\n    // super can be used to call the original CustomView's constructor\n    // This is substantially prettier than the alternative:\n    // `Mn.ItemView.prototype.constructor.apply(this, arguments);`\n    constructor() {\n      \n      // ...do some custom stuff here...\n\n      super();\n    }\n    \n    // Super can also be used to get individual class methods. Neato.\n    serializeData() {\n      var originalData = super.serializeData();\n      originalData.name = 'Custom View';\n      return originalData;\n    }\n\n    // Unfortunately, ES6 does not provide a way to set properties\n    // on the prototype nor instance. Consequently, we can't just set\n    // a template property as we normally might.\n    // As a workaround, we can use getters and setters, as in the following\n    // example, where I specify the template.\n    // This limitation is the primary reason why many people will not choose\n    // to use ES6 classes, I imagine.\n    get template() {\n      return _.template('<%- name %> â€“ Testing out ES6 Classes');\n    }\n\n    // We can, however, place static methods.\n    // This will be accessed via `CustomView.whatever()`\n    static whatever() {\n      return 'Yes you can!';\n    }\n  }\n\n  var customView = new CustomView();\n\n  // We render it and attach it to the body.\n  customView.render();\n  $('body').append(customView.el);\n\n  // Log the result of the static method\n  // console.log('Can I execute a static method?', CustomView.whatever());\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n}));\n"],"sourceRoot":"/source/"}